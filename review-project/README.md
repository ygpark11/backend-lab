# 실전 통합 복습 프로젝트: 실시간 조회수 카운터

## 1. 프로젝트 목표
- **기능**: 특정 게시물의 실시간 조회수를 보여주는 API 개발.
- **요구사항**:
    1. 조회수는 성능을 위해 **Redis**에 먼저 기록한다.
    2. Redis에 누적된 조회수는 **5분마다 스프링 스케줄러**를 통해 DB에 업데이트한다. (실습에서는 로그로 대체)
    3. 전체 시스템(애플리케이션 + Redis)은 **도커**로 한 번에 실행되어야 한다.

---
## 2. 시스템 설계 기록 (Q&A)

### Q1: 조회수를 Redis에 어떻게 저장할 것인가?
- **자료구조**: **Strings**
- **핵심 명령어**: **`INCR [키이름]`**
- **이유**: `GET` -> `+1` -> `SET` 방식은 여러 요청이 동시에 들어올 때 값이 꼬이는 '경쟁 상태(Race Condition)' 문제가 발생할 수 있다. `INCR`은 이 모든 과정을 단 한 번의 '원자적(atomic)' 연산으로 처리하여 데이터의 정합성을 보장한다. 키가 없으면 0을 기준으로 1을 더해주는 편리함도 갖추고 있다.

### Q2: 5분마다 실행되는 분산 스케줄러는 어떻게 구성할 것인가?
- **어노테이션**: `@Component`, `@EnableScheduling`, `@Scheduled`, `@SchedulerLock`
- **`cron` 표현식**: `"0 */5 * * * *"` (매 5분이 되는 시점의 0초에 실행)
- **`@SchedulerLock` 설정**: `lockAtMostFor`는 실행 주기(5분)보다 약간 짧게, `lockAtLeastFor`는 서버 간 시간 오차를 고려하여 1분 정도로 설정하여 안정성을 확보한다.

### Q3: Redis에 쌓인 모든 조회수 키는 어떻게 가져올 것인가?
- **명령어**: **`SCAN`**
- **이유**: `KEYS` 명령어는 데이터가 많을 때 Redis 서버 전체를 멈추게 하는 위험이 있다. `SCAN`은 커서(cursor) 기반으로 조금씩 나누어 검색하므로, 서버를 멈추지 않고 안전하게 모든 키를 순회할 수 있다.

---
## 3. 다음 단계
- 위 설계를 바탕으로, 내일 실제 스프링 부트 코드를 함께 작성하여 기능을 완성한다.