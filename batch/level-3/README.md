# 스프링 배치 학습 - Level 3: Job 흐름 제어

## 1. 핵심 개념 정리
- **Step 흐름 제어**: `Job`은 단순히 `Step`을 실행하는 것을 넘어, 각 `Step`의 실행 결과(**`ExitStatus`**)에 따라 다음에 어떤 `Step`을 실행할지 동적으로 결정할 수 있다.
- **`JobBuilder` API**: `.next()`, `.on()`과 같은 메서드를 체인 형태로 사용하여, 성공, 실패 등 다양한 시나리오에 따른 `Step` 실행 순서를 정의한다.
- **`ExitStatus`**: `Step`이 완료된 후 `JobRepository`에 기록하는 '결과 보고서'. `COMPLETED`, `FAILED`와 같은 문자열 값을 가지며, `Job`의 조건 분기(Flow)는 이 값을 기준으로 동작한다.

---
## 2. 실습 기록 및 Q&A

### 2-1. `FlowJobConfig.java`
- `processDataStep`(Chunk 기반)과 `moveFileStep`(Tasklet 기반)이라는 두 개의 서로 다른 `Step`을 정의했다.
- `Job` 설정에서 `.start(processDataStep).next(moveFileStep)` 구문을 사용하여, 첫 번째 Step이 성공적으로 완료되면 두 번째 Step이 순차적으로 실행되도록 구성했다.

### 2-2. 조건 분기 (핵심 Q&A)

#### Q: `Step`의 성공/실패에 따라 다른 작업을 실행할 수 있는가?
- **A**: 그렇다. `.from(Step).on("FAILED").to(다른Step)` 과 같은 구문을 사용하여 흐름을 제어할 수 있다.
- **동작 원리**: `Step`이 완료되면 `ExitStatus`를 반환하고, `Job`은 이 `ExitStatus` 값과 `.on()`에 지정된 문자열을 비교하여 일치하는 다음 경로를 따라간다. `*`는 '그 외 모든 경우'를 의미하는 와일드카드다.
- **주의점**: `.on()` 조건문의 **순서가 매우 중요**하다. 더 구체적인 조건(예: `FAILED`)을 더 일반적인 조건(예: `*`)보다 항상 먼저 정의해야 의도한 대로 동작한다.

---
## 3. 학습한 내용
- 이번 학습을 통해, 스프링 배치의 `Job`이 여러 `Step`을 조합하여 하나의 완성된 워크플로우를 만들 수 있음을 이해했다.
- 각 `Step`의 실행 결과인 `ExitStatus`를 바탕으로 `.on()`을 통해 흐름을 제어함으로써, 성공 시나리오뿐만 아니라 실패 시나리오까지 견고하게 처리하는 방법을 학습했다.
- 이를 통해 단순한 데이터 처리를 넘어, 복잡한 비즈니스 로직을 가진 배치 애플리케이션을 설계할 수 있는 기초를 다졌다.