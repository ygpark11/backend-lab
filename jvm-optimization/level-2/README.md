# Level 2: IntelliJ 프로파일러를 이용한 성능 분석

## 📝 학습 목표

- IDE에 내장된 IntelliJ 프로파일러를 사용하여 실행 중인 애플리케이션의 성능을 분석하는 방법을 익힘.
- CPU 프로파일러의 'Flame Graph'를 해석하여 성능 병목 지점을 코드 레벨에서 찾아내고, `StringBuilder`를 이용해 최적화하는 과정을 실습함.
- 메모리 프로파일러의 'Biggest Objects' 뷰를 통해 메모리 누수(Memory Leak)의 원인이 되는 객체를 찾아내고, 'GC Root'의 개념을 이해함.

## 📚 학습 목차

1.  **[CPU 프로파일링: 느린 코드의 범인 찾기](#1-cpu-프로파일링-느린-코드의-범인-찾기)**
2.  **[메모리 프로파일링: 메모리 누수 추적하기](#2-메모리-프로파일링-메모리-누수-추적하기)**

---

## 🚀 핵심 학습 내용

### 1. CPU 프로파일링: 느린 코드의 범인 찾기

- **목표**: 특정 API가 느릴 때, 어떤 메소드가 CPU를 가장 많이 사용하는지 찾아내는 것.
- **실행**: 'Run with Profiler' -> 'IntelliJ Profiler'로 애플리케이션 실행.
- **분석 도구: Flame Graph (불꽃 그래프)**
    - **해석**: 그래프의 **'너비(width)'가 넓을수록** 해당 메소드가 CPU 시간을 많이 소비한 '범인'.
    - **실습**: 반복문 내 `String` `+` 연산으로 의도적인 병목 현상을 만들고, Flame Graph가 `cpuIntensiveWork` 메소드를 정확히 지목하는 것을 확인.
- **해결**: `StringBuilder`를 사용하여 코드를 수정한 후, 프로파일러에서 해당 메소드의 너비가 거의 사라지는 것을 통해 최적화 성공을 검증.

### 2. 메모리 프로파일링: 메모리 누수 추적하기

- **목표**: GC에 의해 수거되지 않고 계속 쌓이는 객체(메모리 누수)의 원인을 찾는 것.
- **실행**: 'Run with Profiler' -> 'Memory'로 애플리케이션 실행.
- **분석 도구: Biggest Objects**
    - **해석**: 현재 Heap 메모리에서 가장 큰 용량을 차지하는 객체 목록을 보여줌. 메모리 누수의 가장 유력한 용의자를 빠르게 찾을 수 있음.
    - **실습**: `static` 리스트에 객체를 계속 추가하여 의도적인 메모리 누수를 발생시키고, 'Biggest Objects' 뷰가 해당 `static` 리스트를 정확히 범인으로 지목하는 것을 확인.
- **심화 (GC Roots)**: 'Paths to GC Roots' 기능을 통해, 특정 객체가 왜 GC에 의해 수거되지 않는지(어떤 '뿌리'에 연결되어 있는지) 그 참조 경로를 역추적할 수 있음을 이해.