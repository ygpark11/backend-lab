# 카프카(Kafka) 학습 - Level 2: 컨슈머 그룹과 파티션 (병렬 처리의 시작)

## 1. 핵심 개념 정리
- **파티션 (Partition)**: 토픽(고속도로)을 구성하는 여러 개의 '차선'. 데이터가 실제로 저장되는 단위이며, 파티션의 수가 곧 해당 토픽의 최대 병렬 처리량을 결정한다.
- **컨슈머 그룹 (Consumer Group)**: 하나의 토픽을 구독하는 컨슈머들의 '팀'. 같은 `group-id`를 가진 컨슈머들은 같은 팀 소속이다.
- **리밸런싱 (Rebalancing)**: 팀(컨슈머 그룹)에 새로운 팀원(컨슈머)이 합류하거나 기존 팀원이 이탈할 때, 카프카가 전체 차선(파티션)을 팀원들에게 공평하게 재분배하는 과정. 이를 통해 카프카는 확장성과 장애 극복(Fail-over) 능력을 확보한다.
- **컨슈머와 파티션의 황금률**: 한 팀(컨슈머 그룹) 안에서, 하나의 차선(파티션)은 오직 한 명의 팀원(컨슈머)만 담당할 수 있다. 따라서 `컨슈머 수 <= 파티션 수` 공식을 지켜야 자원 낭비가 없다.
- **`auto.offset.reset`**: 컨슈머 그룹이 토픽을 처음 구독할 때 어디서부터 메시지를 읽을지 결정하는 정책.
    - `latest` (기본값): 구독 시작 이후에 들어오는 최신 메시지만 처리한다.
    - `earliest`: 토픽에 쌓여있는 가장 오래된 메시지부터 모두 처리한다.

---
## 2. 핵심 설정
### 2-1. `docker-compose.yml` (파티션 수 지정)
```yaml
# kafka 서비스 environment:
# 자동 생성되는 토픽의 파티션 수를 3개로 지정
- KAFKA_NUM_PARTITIONS: 3
```

### 2-2. consumer-app/application.yml (Offset 초기화 정책)
```yaml
# consumer:
#   auto.offset.reset: earliest # 처음 구독 시 가장 오래된 메시지부터 소비 (주석 해제 시)
#   auto.offset.reset: latest   # 처음 구독 시 최신 메시지부터 소비 (기본값)
```
---
## 3. 실습 Q&A 및 발견
### Q: 컨슈머를 2대 실행했는데, 왜 모든 메시지가 한쪽으로만 가는가?
- A: 최신 카프카 프로듀서의 기본 전략인 StickyPartitioner 때문이었다. 이는 네트워크 효율을 위해 한 파티션에 메시지를 모아서 보내려는 '단골' 전략이다. partitioner.class를 RoundRobinPartitioner로 강제 변경하여 메시지를 공정하게 분배시키는 실험에 성공했다. (학습 후 다시 기본값으로 되돌림)

### Q: 첫 컨슈머 실행 시, 이전에 보낸 메시지를 왜 읽지 못했는가?
- A: auto.offset.reset 정책의 기본값이 latest이기 때문. 컨슈머 실행 이후에 들어온 메시지만 처리하도록 설정되어 있어, 이미 토픽에 있던 메시지는 무시했다. earliest로 설정을 변경하여 해결했다.

### Q: 컨슈머를 하나 끄면 어떻게 되는가?
- A: '리밸런싱'이 발생하여, 떠난 컨슈머가 담당하던 파티션이 남아있는 다른 컨슈머에게 자동으로 재할당된다. 이를 통해 카프카는 장애 상황에서도 메시지 처리를 지속할 수 있다.

---
## 4. 학습한 내용
- 토픽의 파티션 수를 늘리고, 여러 컨슈머 인스턴스를 실행하여 메시지 처리를 병렬화하는 방법을 학습했다.

- 컨슈머 그룹에 새로운 컨슈머가 참여하거나 이탈할 때 '리밸런싱'이 발생하며 파티션이 재할당되는 과정을 로그를 통해 직접 확인했다.

- auto.offset.reset 정책(latest vs earliest)의 차이를 이해하고, 컨슈머의 초기 메시지 소비 시점을 제어하는 방법을 익혔다.

- 프로듀서의 StickyPartitioner 동작 방식을 이해하고, 필요에 따라 RoundRobinPartitioner로 변경하는 방법을 배웠다.

- 이를 통해 카프카의 핵심 가치인 '확장성'과 '고가용성'이 어떤 원리로 동작하는지 깊이 있게 이해했다.