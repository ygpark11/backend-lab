# 카프카(Kafka) 학습 - Level 2: 컨슈머 그룹과 파티션 (병렬 처리의 시작)

## 1. 핵심 개념 정리
- **파티션 (Partition)**: 토픽(고속도로)을 구성하는 여러 개의 '차선'. 데이터가 실제로 저장되는 단위이며, 파티션의 수가 곧 해당 토픽의 최대 병렬 처리량을 결정한다.
- **컨슈머 그룹 (Consumer Group)**: 하나의 토픽을 구독하는 컨슈머들의 '팀'. 같은 `group-id`를 가진 컨슈머들은 같은 팀 소속이다.
- **리밸런싱 (Rebalancing)**: 팀(컨슈머 그룹)에 새로운 팀원(컨슈머)이 합류하거나 기존 팀원이 이탈할 때, 카프카가 전체 차선(파티션)을 팀원들에게 공평하게 재분배하는 과정. 이를 통해 카프카는 확장성과 장애 극복(Fail-over) 능력을 확보한다.
- **컨슈머와 파티션의 황금률**: 한 팀(컨슈머 그룹) 안에서, 하나의 차선(파티션)은 오직 한 명의 팀원(컨슈머)만 담당할 수 있다. 따라서 `컨슈머 수 <= 파티션 수` 공식을 지켜야 자원 낭비가 없다.
- **`auto.offset.reset`**: 컨슈머 그룹이 토픽을 처음 구독할 때 어디서부터 메시지를 읽을지 결정하는 정책.
    - `latest` (기본값): 구독 시작 이후에 들어오는 최신 메시지만 처리한다.
    - `earliest`: 토픽에 쌓여있는 가장 오래된 메시지부터 모두 처리한다.

---
## 2. 핵심 설정
### 2-1. `docker-compose.yml` (파티션 수 지정)
```yaml
# kafka 서비스 environment:
# 자동 생성되는 토픽의 파티션 수를 3개로 지정
- KAFKA_NUM_PARTITIONS: 3
```

### 2-2. consumer-app/application.yml (Offset 초기화 정책)
```yaml
# consumer:
#   auto.offset.reset: earliest # 처음 구독 시 가장 오래된 메시지부터 소비 (주석 해제 시)
#   auto.offset.reset: latest   # 처음 구독 시 최신 메시지부터 소비 (기본값)
```
---
## 3. 실습 Q&A 및 발견
### Q: 컨슈머를 2대 실행했는데, 왜 모든 메시지가 한쪽으로만 가는가?
- A: 최신 카프카 프로듀서의 기본 전략인 StickyPartitioner 때문이었다. 이는 네트워크 효율을 위해 한 파티션에 메시지를 모아서 보내려는 '단골' 전략이다. partitioner.class를 RoundRobinPartitioner로 강제 변경하여 메시지를 공정하게 분배시키는 실험에 성공했다. (학습 후 다시 기본값으로 되돌림)

### Q: 첫 컨슈머 실행 시, 이전에 보낸 메시지를 왜 읽지 못했는가?
- A: auto.offset.reset 정책의 기본값이 latest이기 때문. 컨슈머 실행 이후에 들어온 메시지만 처리하도록 설정되어 있어, 이미 토픽에 있던 메시지는 무시했다. earliest로 설정을 변경하여 해결했다.

### Q: 컨슈머가 처리 중 실패하면 메시지는 어떻게 되는가?
- A: 메시지는 유실되지 않는다. 컨슈머는 메시지 처리를 성공적으로 마친 후에만 '완료 보고(Offset Commit)'를 한다. 만약 처리 중 실패하면 이 보고를 하지 못했기 때문에, 리밸런싱 후 다른 컨슈머가 마지막 보고 지점부터 메시지를 다시 가져가 처리한다 ('최소 한 번 처리 보장').

### Q: API 직접 호출 방식과 카프카는 무엇이 다른가?
- A: '전화 통화(동기)'와 '문자 메시지(비동기)'의 차이다. API 호출은 상대방의 응답을 기다려야 하고(강한 결합), 상대방이 다운되면 나까지 장애가 전파된다. 카프카는 메시지를 던져두고 내 할 일에 집중할 수 있으며(약한 결합), 상대방이 다운되어도 메시지가 유실되지 않아 시스템 전체가 훨씬 안정적이다.

---
## 4. 학습한 내용
- 토픽의 파티션 수를 늘리고, 여러 컨슈머 인스턴스를 실행하여 메시지 처리를 병렬화하는 방법을 학습했다.

- 컨슈머 그룹에 새로운 컨슈머가 참여하거나 이탈할 때 '리밸런싱'이 발생하며 파티션이 재할당되는 과정을 로그로 직접 확인했다.

- auto.offset.reset 정책과 프로듀서의 Sticky Partitioner 동작을 실험하며, 메시지 소비의 주요 옵션들을 학습했다.

- 컨슈머 장애 시 메시지가 유실되지 않는 원리(Offset Commit)와, API 호출 대비 카프카의 비동기 아키텍처가 갖는 이점을 깊이 있게 이해했다.

- 이를 통해 카프카의 핵심 가치인 '확장성', '고가용성', '결합도 분리'가 어떤 원리로 동작하는지 깊이 있게 이해했다.