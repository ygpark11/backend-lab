# Level 2: DB 쿼리 최적화 심화 (실행 계획 & 인덱스 설계)

## 📝 학습 목표

- MySQL `EXPLAIN`의 상세 결과(`type`, `Extra` 등)를 해독하여 쿼리의 성능을 정밀하게 분석하는 능력을 기름.
- 인덱스 설계의 핵심 기준(카디널리티, 쿼리 빈도 등)을 이해하고, 실무적인 관점에서 최적의 인덱스를 설계하는 방법을 학습함.
- 복합 인덱스의 컬럼 순서 결정 규칙을 이해하고, 실제 쿼리(`WHERE`, `GROUP BY`, `ORDER BY`)에 맞춰 최적의 인덱스를 설계하는 능력을 배양함.

## 📚 학습 목차

1.  **[`EXPLAIN` 실행 계획 완벽 해부](#1-explain-실행-계획-완벽-해부)**
2.  **[인덱스 설계 전략: 무엇을, 어떻게?](#2-인덱스-설계-전략-무엇을-어떻게)**
3.  **[복합 인덱스 설계의 황금률](#3-복합-인덱스-설계의-황금률)**

---

## 🚀 핵심 학습 내용

### 1. `EXPLAIN` 실행 계획 완벽 해부 🩺

- **정의**: MySQL이 쿼리를 어떻게 실행할지 알려주는 '설계도'. 쿼리 튜닝의 시작과 끝.
- **핵심 필드 1: `type` (접근 방식)**
    - 쿼리가 얼마나 효율적으로 데이터에 접근했는지 보여주는 **'성능 등급표'**. 최소 `range` 이상을 목표로 함.

| `type` | 비유 | 설명 |
| :--- | :--- | :--- |
| **`const`** | 🎯 **과녁 정중앙** | `UNIQUE` 키나 `PRIMARY KEY`로 단 **1건**의 데이터를 정확히 찾아냄 (가장 빠름) |
| **`ref`** | 📚 **색인(Index) 바로 찾기** | 인덱스를 사용해 일치하는 **여러 건**의 데이터를 효율적으로 찾아냄 (매우 좋음) |
| **`range`** | 📖 **책의 특정 범위 펼치기** | 인덱스를 사용해 특정 **범위**(`BETWEEN`, `>`, `<`)의 데이터를 찾아냄 (좋음) |
| **`index`** | 📑 **색인 페이지만 모두 읽기** | 테이블 전체 대신 **인덱스 페이지만** 처음부터 끝까지 스캔 (느림) |
| **`ALL`** | 🏃‍♂️ **도서관 전체 뛰어다니기** | **테이블 전체**를 처음부터 끝까지 스캔 (가장 느리고 최악) |

- **핵심 필드 2: `Extra` (추가 정보)**
    - 쿼리의 숨겨진 동작을 알려주는 '탐정의 메모'.

| `Extra` 값 | 신호 | 설명 |
| :--- | :--- | :--- |
| **`Using index`** | 👍 **최고** | **커버링 인덱스**. 테이블 접근 없이 인덱스만으로 쿼리 해결. |
| **`Using where`** | 😐 **보통** | 인덱스로 데이터를 찾은 후, 추가 필터링 작업 수행. |
| **`Using filesort`**| 👎 **최악** | 인덱스를 사용하지 못해, 별도의 느린 정렬 작업을 수행. (`ORDER BY` 튜닝 필요) |

### 2. 인덱스 설계 전략: 무엇을, 어떻게?

- **'무엇을' 인덱스로 만들까? (인덱스 후보군 Top 4)**
    - `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY` 순서대로 인덱스 생성 시 중요도를 고려함.

| 질문 | 가이드라인 | 비유 |
| :--- | :--- | :--- |
| **"어떤 인덱스를 만들까?"**<br>(전략) | 1.`WHERE` 2.`JOIN` 3.`ORDER BY` 4.`GROUP BY` | '어떤 도서관'에 가야 할지 정하기 |
| **"복합 인덱스 컬럼 순서는?"**<br>(전술) | 1.`WHERE`(=) 2.`GROUP BY` 3.`ORDER BY` | 한 도서관 안에서 '어떤 순서로' 책을 찾을지 정하기 |

- **'어떻게' 가치를 판단할까? (인덱스 가치 판단 기준)**
    - **카디널리티 (Cardinality)**: 컬럼의 고유한 값 분포도. 높을수록 좋음.
        - **선택도(Selectivity)**: `고유값 수 / 전체 행 수 * 100`. 일반적으로 **10~15% 이상**일 때 인덱스 생성 고려.
    - **쿼리 빈도**: 자주 쓰는 쿼리가 우선.
    - **쓰기 비용**: 인덱스는 `INSERT`, `UPDATE`, `DELETE`를 느리게 하므로, 꼭 필요한 곳에만 최소한으로 생성.

### 3. 복합 인덱스 설계의 황금률

- **핵심 규칙**: **"좁은 범위부터 검색하도록 순서를 정한다."**
- **컬럼 순서 결정**:
    1.  **등호(`=`) 조건**에 사용되는 컬럼을 가장 앞으로.
    2.  그 다음 **범위(`>`, `<`, `BETWEEN`) 조건**에 사용되는 컬럼을 뒤로.
- **옵티마이저**: `WHERE` 절에 작성된 컬럼의 순서는 중요하지 않음. MySQL 옵티마이저가 인덱스에 맞게 순서를 재조합하여 최적의 실행 계획을 찾음.