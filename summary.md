도커 마스터 클래스 (Level 1 ~ 3)
Level 1: 도커와 컨테이너 이해하기 (개념 정립)
🤔 핵심 개념
도커란?: "제 컴퓨터에선 됐는데..." 문제를 해결하는 '개발 밀키트 시스템'. 애플리케이션을 실행 환경과 함께 '이미지'로 완벽하게 포장하여, 어떤 컴퓨터에서든 동일하게 동작하도록 보장하는 기술.

이미지(Image) vs 컨테이너(Container):

이미지 (붕어빵 틀): 애플리케이션 실행에 필요한 모든 것(코드, 라이브러리)을 담은 '설계도'.

컨테이너 (붕어빵): 이미지라는 '틀'을 사용해 실제로 실행한 '인스턴스'.

가상 머신(VM) vs 컨테이너: 컨테이너는 OS를 공유하므로 VM('독채 주택')보다 훨씬 가볍고 빠르다. 컨테이너는 잘 지어진 '아파트'에 효율적으로 방 하나만 빌려 쓰는 것과 같다.

💻 실습 요약
docker pull [이미지이름]: 원격 저장소(도커 허브)에서 이미지(붕어빵 틀)를 다운로드한다.

docker run [이미지이름]: 이미지(틀)를 사용해 컨테이너(붕어빵)를 실행한다.

docker images: 내 PC에 있는 이미지(틀) 목록을 확인한다.

docker ps -a: 생성된 모든 컨테이너(붕어빵) 목록을 확인한다.

❓ Q&A 정리
Q: docker run redis를 세 번 실행하면?

A: redis 이미지는 1개, 컨테이너는 3개가 생성된다.

Level 2: 나만의 이미지 만들기 (Dockerfile)
🤔 핵심 개념
Dockerfile: 나만의 이미지를 만들기 위한 '레시피' 파일. FROM, COPY, RUN, ENTRYPOINT 등의 명령어를 사용하여 이미지 생성 과정을 정의한다.

레이어 캐시(Layer Cache): Dockerfile의 각 줄은 '레이어'라는 단위로 캐시된다. 빌드 시 변경되지 않은 줄은 다시 실행하지 않고 캐시를 재사용하여 빌드 속도를 획기적으로 높인다.

빌드 컨텍스트(Build Context): 도커는 Dockerfile의 텍스트뿐만 아니라, COPY되는 파일의 내용까지 확인하여 변경 여부를 감지한다.

💻 실습 요약
Spring Boot JAR 파일 준비: start.spring.io를 통해 프로젝트를 생성하고, 간단한 코드를 작성한 뒤 ./gradlew build로 실행 가능한 .jar 파일을 만든다.

Dockerfile 작성: FROM으로 베이스 이미지를 지정하고, COPY로 .jar 파일을 복사한 뒤, ENTRYPOINT로 실행 명령어를 정의한다.

docker build -t [태그] .: Dockerfile을 읽어 커스텀 이미지를 생성한다.

docker run -p [호스트포트]:[컨테이너포트] [이미지태그]: 생성한 이미지를 컨테이너로 실행하고, -p 옵션으로 포트를 연결하여 외부에서 접속할 수 있게 한다.

❓ Q&A 정리
Q: Dockerfile 변경 후 같은 태그로 다시 빌드하면?

A: 기존 이미지는 이름표(태그)를 잃고 댕글링 이미지가 되며, 새로운 이미지가 그 태그를 가져간다.

Q: 댕글링 이미지는 자동으로 사라지나?

A: 아니다. docker image prune 명령어로 직접 삭제해야 한다.

Q: 아무것도 안 바꾸고 다시 빌드하면?

A: 레이어 캐시를 100% 사용하여 1초 만에 끝난다. 새로운 이미지는 생성되지 않는다.

Q: 태그만 바꿔서 빌드하면?

A: 새로운 이미지는 생성되지 않고, 기존 이미지에 태그(이름표)만 하나 더 추가된다. 차지하는 용량 변화는 거의 없다.

Q: 소스코드의 주석만 바꿔도 새로운 이미지가 되나?

A: **'무엇을 COPY 하느냐'**에 따라 다르다.

빌드된 .jar 파일을 COPY하면 -> .jar 내용이 그대로이므로 캐시 사용 (새 이미지 X)

.java 소스코드를 COPY하면 -> 소스 파일 내용이 바뀌었으므로 캐시 깨짐 (새 이미지 O)

Level 3: 여러 컨테이너 엮어내기 (Docker Compose)
🤔 핵심 개념
Docker Compose: 여러 컨테이너를 하나의 docker-compose.yml 파일로 정의하고 관리하는 도구.

docker-compose.yml: 컨테이너 마을의 '건축 설계 총괄도'. 각 서비스(컨테이너)의 빌드 방식, 이미지, 포트, 의존성, 네트워크 등을 모두 정의한다.

서비스 디스커버리(Service Discovery): Compose로 실행된 컨테이너들은 같은 내부 네트워크에 속하게 된다. 이 네트워크 안에서는 IP 주소 대신 서비스 이름을 hostname처럼 사용하여 서로 통신할 수 있다.

💻 실습 요약
docker-compose.yml 작성: services 항목 아래에 my-app, my-redis 등 각 컨테이너의 설정을 정의한다.

docker-compose up -d: 정의된 모든 서비스를 백그라운드에서 실행한다. (-d 옵션이 없으면 Foreground로 실행되어 로그가 터미널을 점유한다.)

docker-compose down: 실행된 모든 컨테이너, 네트워크 등을 한 번에 중지하고 제거한다.

❓ Q&A 정리
Q: localhost:8080은 접속되는데, localhost:6379는 왜 브라우저에서 안 보이나?

A: 접속은 되지만, 브라우저(HTTP)와 Redis 서버(RESP)는 서로 **'대화 언어(프로토콜)'**가 달라 정상적인 통신이 불가능하기 때문이다.

Q: my-app에서 my-redis에 접속하려면 주소를 어떻게 써야 하나?

A: localhost가 아닌 서비스 이름, 즉 my-redis:6379 라고 써야 한다. 컨테이너 내부에서 localhost는 자기 자신을 의미하기 때문이다.

Q: 브라우저에서 my-redis:6379로 접속이 되나?

A: 안 된다. 서비스 이름은 Docker Compose가 만들어준 내부 네트워크에서만 통용되는 주소이기 때문이다. **외부(내 PC)**에서 컨테이너로 접속하려면 항상 localhost와 ports로 연결된 포트를 사용해야 한다.
